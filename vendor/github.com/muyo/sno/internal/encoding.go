// +build !amd64

package internal

const (
	// The encoding is a custom base32 variant stemming from base32hex.
	// The alphabet is 2 contiguous ASCII ranges: `50..57` (digits) and `97..120` (lowercase letters).
	// A canonically encoded ID can be validated with a regexp of `[2-9a-x]{16}`.
	enc = "23456789abcdefghijklmnopqrstuvwx"
)

var (
	// Decoding LUT.
	dec = [256]byte{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
		0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	}

	// Dummy flag to be set by the respective build (used by tests).
	hasVectorSupport bool
)

// Encode returns the sno32-encoded representation of src as an array of 16 bytes.
func Encode(src *[10]byte) (dst [16]byte) {
	dst[15] = enc[src[9]&0x1F]
	dst[14] = enc[(src[9]>>5|src[8]<<3)&0x1F]
	dst[13] = enc[src[8]>>2&0x1F]
	dst[12] = enc[(src[8]>>7|src[7]<<1)&0x1F]
	dst[11] = enc[(src[7]>>4|src[6]<<4)&0x1F]
	dst[10] = enc[src[6]>>1&0x1F]
	dst[9] = enc[(src[6]>>6|src[5]<<2)&0x1F]
	dst[8] = enc[src[5]>>3]

	dst[7] = enc[src[4]&0x1F]
	dst[6] = enc[(src[4]>>5|src[3]<<3)&0x1F]
	dst[5] = enc[src[3]>>2&0x1F]
	dst[4] = enc[(src[3]>>7|src[2]<<1)&0x1F]
	dst[3] = enc[(src[2]>>4|src[1]<<4)&0x1F]
	dst[2] = enc[src[1]>>1&0x1F]
	dst[1] = enc[(src[1]>>6|src[0]<<2)&0x1F]
	dst[0] = enc[src[0]>>3]

	return
}

// Decode returns the binary representation of a sno32-encoded src as an array of bytes.
//
// Src does not get validated and must have a length of 16 - otherwise Decode will panic.
func Decode(src []byte) (dst [10]byte) {
	_ = src[15] // BCE hint.

	dst[9] = dec[src[14]]<<5 | dec[src[15]]
	dst[8] = dec[src[12]]<<7 | dec[src[13]]<<2 | dec[src[14]]>>3
	dst[7] = dec[src[11]]<<4 | dec[src[12]]>>1
	dst[6] = dec[src[9]]<<6 | dec[src[10]]<<1 | dec[src[11]]>>4
	dst[5] = dec[src[8]]<<3 | dec[src[9]]>>2

	dst[4] = dec[src[6]]<<5 | dec[src[7]]
	dst[3] = dec[src[4]]<<7 | dec[src[5]]<<2 | dec[src[6]]>>3
	dst[2] = dec[src[3]]<<4 | dec[src[4]]>>1
	dst[1] = dec[src[1]]<<6 | dec[src[2]]<<1 | dec[src[3]]>>4
	dst[0] = dec[src[0]]<<3 | dec[src[1]]>>2

	return
}
